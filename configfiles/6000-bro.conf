# Author: Justin Henderson, Phil Hagen
# Email: jhenderson@tekrefresh.comes, phil@lewestech.com
# Last Update: 2016-03-13
#
# This conf file is based on accepting logs for conn.log from Bro systems

filter {
  if "bro" in [tags] {

    date {
      match => [ "timestamp", "UNIX" ]
    }

    # remove the original timestamp field, as it's been moved to @timestamp, per above
    mutate {
      remove_field => [ "timestamp" ]
    }

    # If numerical values are unspecified, set them to zero so the ES template will convert them to integers
    if [duration] == "-" {
      mutate {
        replace => { "duration" => "0" }
      }
    }
    if [out_bytes] == "-" {
      mutate {
        replace => { "out_bytes" => "0" }
      }
    }
    if [missed_bytes] == "-" {
      mutate {
        replace => { "missed_bytes" => "0" }
      }
    }
    if [out_ipbytes] == "-" {
      mutate {
        replace => { "out_ipbytes" => "0" }
      }
    }
    if [in_bytes] == "-" {
      mutate {
        replace => { "in_bytes" => "0" }
      }
    }
    if [in_ipbytes] == "-" {
      mutate {
        replace => { "in_ipbytes" => "0" }
      }
    }
    if [total_bytes] == "-" {
      mutate {
        replace => { "total_bytes" => "0" }
      }
    }
    if [seen_bytes] == "-" {
      mutate {
        replace => { "seen_bytes" => "0" }
      }
    }
    if [missing_bytes] == "-" {
      mutate {
        replace => { "missing_bytes" => "0" }
      }
    }
    if [overflow_bytes] == "-" {
      mutate {
        replace => { "overflow_bytes" => "0" }
      }
    }

    # remove fields with empty or otherwise unspecified values
    if [source_port] == "-" {
      mutate {
        remove_field => [ "source_port" ]
      }
    }
    if [destination_port] == "-" {
      mutate {
        remove_field => [ "destination_port" ]
      }
    }
    if [virtual_host] == "-" {
      mutate {
        remove_field => [ "virtual_host" ]
      }
    }
    if [tunnel_parents] == "(empty)" {
      mutate {
        remove_field => [ "tunnel_parents" ]
      }
    }
    if [service] == "-" {
      mutate {
        remove_field => [ "service" ]
      }
    }

    # I renamed conn_uids to uid so that it is easy to pivot to all things tied to a connection
    mutate {
       rename => { "connection_uids" => "uid" }
    }

    # TODO: I think we can do this better in ES with a scripted field
    # Combine in_bytes and out_bytes and save the value to total_bytes
    if [in_bytes] and [out_bytes] {
      ruby {
        code => "event['total_bytes'] = event['in_bytes'] + event['out_bytes']"
      }
    }

    if [bound_port] {
      mutate {
        convert => { "bound_port" => "integer" }
      }
    }
    if [data_channel_destination_port] {
      mutate {
        convert => { "data_channel_destination_port" => "integer" }
      }
    }
    if [destination_port] {
      mutate {
        convert => { "destination_port" => "integer" }
      }
    }
    if [depth] {
      mutate {
        convert => { "depth" => "integer" }
      }
    }
    if [duration] {
      mutate {
        convert => { "duration" => "float" }
      }
    }
    if [info_code] {
      mutate {
        convert => { "info_code" => "integer" }
      }
    }
    if [missed_bytes] {
      mutate {
        convert => { "missed_bytes" => "integer" }
      }
    }
    if [missing_bytes] {
      mutate {
        convert => { "missing_bytes" => "integer" }
      }
    }
    if [n] {
      mutate {
        convert => { "n" => "integer" }
      }
    }
    if [in_bytes] {
      mutate {
        convert => { "in_bytes" => "integer" }
      }
    }
    if [in_packets] {
      mutate {
        convert => { "in_packets" => "integer" }
      }
    }
    if [in_ipbytes] {
      mutate {
        convert => { "in_ipbytes" => "integer" }
      }
    }
    if [overflow_bytes] {
      mutate {
        convert => { "overflow_bytes" => "integer" }
      }
    }
    if [p] {
      mutate {
        convert => { "p" => "integer" }
      }
    }
    if [query_class] {
      mutate {
        convert => { "query_class" => "integer" }
      }
    }
    if [query_type] {
      mutate {
        convert => { "query_type" => "integer" }
      }
    }
    if [rcode] {
      mutate {
        convert => { "rcode" => "integer" }
      }
    }
    if [request_body_length] {
      mutate {
        convert => { "request_body_length" => "integer" }
      }
    }
    if [request_port] {
      mutate {
        convert => { "request_port" => "integer" }
      }
    }
    if [out_bytes] {
      mutate {
        convert => { "out_bytes" => "integer" }
      }
    }
    if [out_packets] {
      mutate {
        convert => { "out_packets" => "integer" }
      }
    }
    if [out_ipbytes] {
      mutate {
        convert => { "out_ipbytes" => "integer" }
      }
    }
    if [response_body_length] {
      mutate {
        convert => { "response_body_length" => "integer" }
      }
    }
    if [seen_bytes] {
      mutate {
        convert => { "seen_bytes" => "integer" }
      }
    }
    if [source_port] {
      mutate {
        convert => { "source_port" => "integer" }
      }
    }
    if [status_code] {
      mutate {
        convert => { "status_code" => "integer" }
      }
    }
    if [suppress_for] {
      mutate {
        convert => { "suppress_for" => "float" }
      }
    }
    if [total_bytes] {
      mutate {
        convert => { "total_bytes" => "integer" }
      }
    }
    if [trans_depth] {
      mutate {
        convert => { "trans_depth" => "integer" }
      }
    }
    if [transaction_id] {
      mutate {
        convert => { "transaction_id" => "integer" }
      }
    }
    if [flow_records] {
      mutate {
        convert => { "flow_records" => "integer" }
      }
    }
    if [source_local] {
      mutate {
        convert => { "source_local" => "boolean" }
      }
    }
    if [destination_local] {
      mutate {
        convert => { "destination_local" => "boolean" }
      }
    }
    mutate {
      convert => {
        "ttl" => "integer"
        "authoritative" => "boolean"
        "truncated" => "boolean"
        "recursion_desired" => "boolean"
        "recursion_available" => "boolean"
        "rejected" => "boolean"
      }
    }
  }
}