# SOF-ELK Configuration File
# (C)2016 Lewes Technology Consulting, LLC
#
# This file contains filters, transforms, and enrichments for NetFlow records

filter {
    if [type] == "archive-netflow" {
        grok {
            patterns_dir => "/usr/local/sof-elk/grok-patterns"
            match => [ "message", "(?:%{IPORHOST:netflowhost})?(?:%{SPACE})?%{NONNEGINT:destination_as:int}%{SPACE}%{NONNEGINT:destination_mask:int}%{SPACE}%{NONNEGINT:engine_type:int}/%{NONNEGINT:engine_id:int}%{SPACE}%{TIMESTAMP_NETFLOW:first_switched_raw}%{SPACE}%{NONNEGINT:flow_records}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:in_bytes}%{SPACE}%{NONNEGINT:in_pkts}%{SPACE}%{NONNEGINT:input_snmp:int}%{SPACE}%{IPV4:destination_ip}%{SPACE}%{IPV4:next_hop_ip}%{SPACE}%{IPV4:source_ip}%{SPACE}(%{ICMP_TYPECODE}|%{NONNEGINT:l4_destination_port:int})%{SPACE}%{NONNEGINT:l4_source_port:int}%{SPACE}%{TIMESTAMP_NETFLOW:last_switched_raw}%{SPACE}%{NONNEGINT:output_snmp:int}%{SPACE}%{WORD:protocol}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:source_as:int}%{SPACE}%{NONNEGINT:source_mask:int}%{SPACE}%{NONNEGINT:source_tos:int}%{SPACE}%{NOTSPACE:tcp_aflags}%{SPACE}%{NONNEGINT:version:int}" ]
            remove_field => [ "message", "MSECOND" ]
        }
        if [netflowhost] {
            mutate {
                replace => [ "host", "%{netflowhost}" ]
            }

        } else {
            mutate {
                replace => [ "host", "0.0.0.0" ]
            }
        }
        mutate {
            remove_field => [ "netflowhost", "path" ]
        }
    }

    if [type] == "archive-netflow" {
        # use the flow start timestamp for the event timestamp
        ##  2014-05-11 16:25:11.841 (archived from nfdump)
        date {
            match => [ "first_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" ]
        }

## attempting to unify timestamp formats between live and archive
        date {
            match => [ "first_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" ]
            target => "first_switched"
        }
        date {
            match => [ "last_switched_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" ]
            target => "last_switched"
        }
        mutate {
            remove_field => [ "first_switched_raw", "last_switched_raw" ]
        }
## end datestamp unification attempt
    }

    if [type] == "netflow" {
        # use the flow start timestamp for the event timestamp
        ##  2014-10-14T00:41:56.999Z (live netflow)
        date {
            match => [ "first_switched", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601" ]
        }

        if [tcp_flags] {
            translate {
                dictionary_path => "/usr/local/sof-elk/lib/dictionaries/tcp_flags_int2netflow.yaml"
                field => "tcp_flags"
                destination => "tcp_aflags"
                remove_field => [ "tcp_flags" ]
            }
        }
    }

    if [type] == "netflow" {
### rename fields to remove the [nf] superfield, to better allow ES dynamic mappings, and to enforce field naming hygiene
      mutate {
        rename => {
          "[nf][in_bytes]" => "in_bytes"
          "[nf][in_pkts]" => "in_pkts"
          "[nf][flows]" => "flows"
          "[nf][protocol]" => "protocol"
          "[nf][source_tos]" => "source_tos"
          "[nf][tcp_flags]" => "tcp_flags"
          "[nf][l4_source_port]" => "source_port"
          "[nf][ipv4_source_addr]" => "source_ip"
          "[nf][source_mask]" => "source_mask"
          "[nf][input_snmp]" => "input_snmp"
          "[nf][l4_destination_port]" => "4_destination_port"
          "[nf][ipv4_destination_addr]" => "destination_ip"
          "[nf][destination_mask]" => "destination_mask"
          "[nf][output_snmp]" => "output_snmp"
          "[nf][ipv4_next_hop]" => "next_hop_ip"
          "[nf][source_as]" => "source_as"
          "[nf][destination_as]" => "destination_as"
          "[nf][bgp_ipv4_next_hop]" => "bgp_next_hop_ip"
          "[nf][mul_destination_pkts]" => "mul_destination_pkts"
          "[nf][mul_destination_bytes]" => "mul_destination_bytes"
          "[nf][last_switched]" => "last_switched"
          "[nf][first_switched]" => "first_switched"
          "[nf][out_bytes]" => "out_bytes"
          "[nf][out_pkts]" => "out_pkts"
          "[nf][min_pkt_length]" => "min_pkt_length"
          "[nf][max_pkt_length]" => "max_pkt_length"
          "[nf][ipv6_source_addr]" => "source_ip"
          "[nf][ipv6_destination_addr]" => "destination_ip"
          "[nf][ipv6_source_mask]" => "source_mask"
          "[nf][ipv6_destination_mask]" => "destination_mask"
          "[nf][ipv6_flow_label]" => "flow_label"
          "[nf][mul_igmp_type]" => "mul_igmp_type"
          "[nf][sampling_interval]" => "sampling_interval"
          "[nf][sampling_algorithm]" => "sampling_algorithm"
          "[nf][flow_active_timeout]" => "flow_active_timeout"
          "[nf][flow_inactive_timeout]" => "flow_inactive_timeout"
          "[nf][engine_type]" => "engine_type"
          "[nf][engine_id]" => "engine_id"
          "[nf][total_bytes_exp]" => "total_bytes_exp"
          "[nf][total_pkts_exp]" => "total_pkts_exp"
          "[nf][total_flows_exp]" => "total_flows_exp"
          "[nf][ipv4_source_prefix]" => "source_prefix"
          "[nf][ipv4_destination_prefix]" => "destination_prefix"
          "[nf][mpls_top_label_type]" => "mpls_top_label_type"
          "[nf][mpls_top_label_ip_addr]" => "mpls_top_label_ip"
          "[nf][flow_sampler_id]" => "flow_sampler_id"
          "[nf][flow_sampler_mode]" => "flow_sampler_mode"
          "[nf][flow_sampler_random_interval]" => "flow_sampler_random_interval"
          "[nf][min_ttl]" => "min_ttl"
          "[nf][max_ttl]" => "max_ttl"
          "[nf][ipv4_ident]" => "ident"
          "[nf][destination_tos]" => "destination_tos"
          "[nf][in_source_mac]" => "in_source_mac"
          "[nf][out_destination_mac]" => "out_destination_mac"
          "[nf][source_vlan]" => "source_vlan"
          "[nf][destination_vlan]" => "destination_vlan"
          "[nf][ip_protocol_version]" => "ip_protocol_version"
          "[nf][direction]" => "direction"
          "[nf][ipv6_next_hop]" => "next_hop_ip"
          "[nf][bgp_ipv6_next_hop]" => "bgp_next_hop_ip"
          "[nf][ipv6_option_headers]" => "option_headers"
          "[nf][in_destination_mac]" => "in_destination_mac"
          "[nf][out_source_mac]" => "out_source_mac"
          "[nf][if_name]" => "if_name"
          "[nf][if_desc]" => "if_desc"
          "[nf][sampler_name]" => "sampler_name"
          "[nf][in_permanent_bytes]" => "in_permanent_bytes"
          "[nf][in_permanent_pkts]" => "in_permanent_pkts"
          "[nf][forwarding_status]" => "forwarding_status"
          "[nf][flow_end_reason]" => "flow_end_reason"
          "[nf][conn_id]" => "conn_id"
          "[nf][icmp_type]" => "icmp_type"
          "[nf][icmp_code]" => "icmp_code"
          "[nf][icmp_type_ipv6]" => "icmp_type"
          "[nf][icmp_code_ipv6]" => "icmp_code"
          "[nf][xlate_source_addr_ipv6]" => "xlate_source_ip"
          "[nf][xlate_destination_addr_ipv6]" => "xlate_destination_ip"
          "[nf][fw_ext_event]" => "fw_ext_event"
          "[nf][event_time_msec]" => "event_time_msec"
          "[nf][flow_start_msec]" => "flow_start_msec"
          "[nf][fwd_flow_delta_bytes]" => "fwd_flow_delta_bytes"
          "[nf][rev_flow_delta_bytes]" => "rev_flow_delta_bytes"
          "[nf][ingress_acl_id]" => "ingress_acl_id"
          "[nf][gress_acl_id]" => "gress_acl_id"
          "[nf][username]" => "username"
          "[nf][xlate_source_addr_ipv4]" => "xlate_source_ip"
          "[nf][xlate_destination_addr_ipv4]" => "xlate_destination_ip"
          "[nf][xlate_source_port]" => "xlate_source_port"
          "[nf][xlate_destination_port]" => "xlate_destination_port"
          "[nf][fw_event]" => "fw_event"
          "[nf][application_id]" => "application_id"
          "[nf][udp_source_port]" => "udp_source_port"
          "[nf][udp_destination_port]" => "udp_destination_port"
          "[nf][tcp_source_port]" => "tcp_source_port"
          "[nf][tcp_destination_port]" => "tcp_destination_port"
        }
      }
    }

    if [type] == "netflow" or [type] == "archive-netflow" {
        # replace the numerical protocol number with a text equivalent
        translate {
            dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_int2netflow.yaml"
            field => "protocol"
            destination => "aproto"
        }

        if [in_bytes] {
            mutate {
                convert => [ "in_bytes", "integer" ]
            }
        }
        if [flow_records] {
            mutate {
                convert => [ "flow_records", "integer" ]
            }
        }
        if [in_pkts] {
            mutate {
                convert => [ "in_pkts", "integer" ]
            }
        }

        mutate {
            add_field => { "path" => "NetFlow from %{host}" }

            # geoip needs IPs to be strings, not ip types
            convert => [ "source_ip", "string" ]
            convert => [ "destination_ip", "string" ]
        }
    }

    if [type] == "archive-netflow" {
        if [aproto] == "ICMP" {
            mutate {
                replace => [ "source_port", "%{icmp_type}" ]
            }
            mutate {
                replace => [ "l4_destination_port", "%{icmp_code}" ]
            }
            mutate {
                remove_field => [ "icmp_type", "icmp_code" ]
            }
        }
    }
}
