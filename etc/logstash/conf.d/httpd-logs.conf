input {
    file {
        type => "httpdlog"
        path => [ "/usr/local/logstash-httpd/**/*" ]
        sincedb_path => "/var/db/logstash/sincedb"
        start_position => "beginning"
        exclude => [ "*.gz", "*.zip" ]
    }
    syslog {
        port => 5515
        type => "httpdlog"
        use_labels => false
    }
}

filter {
    # this should only occur with syslog-based source records
    if [type] == "httpdlog" and [logsource] {
        mutate {
            add_field => { "path" => "HTTPD log from %{logsource}" }
            # the syslog handler populates this with the syslog-based date. we don't want that, though - we'll replace with the date parsed from the http log entry below
            remove_field => [ "timestamp" ]
        }
    }
    if [type] == "httpdlog" {
        grok {
            # syslog-based entries, as used on my own servers (HTTP access log pushed via syslog messages)
            match => [ "message", "%{SYSLOGTIMESTAMP} (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource} %{SYSLOGPROG}: %{HOSTNAME:httpd_vhost} %{COMBINEDAPACHELOG}" ]
            match => [ "message", "%{SYSLOGTIMESTAMP} (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource} %{SYSLOGPROG}: %{HOSTNAME:httpd_vhost} %{COMMONAPACHELOG}" ]
            # live syslog-based data, partially parsed via the syslog{} input selector
            match => [ "message", "%{HOSTNAME:httpd_vhost} %{COMBINEDAPACHELOG}" ]
            match => [ "message", "%{HOSTNAME:httpd_vhost} %{COMMONAPACHELOG}" ]
            # straight-out NCSA combined/common formats.  combined has to go first, since common will match a combined entry as well - and we break on first match
            match => [ "message", "%{COMBINEDAPACHELOG}" ]
            match => [ "message", "%{COMMONAPACHELOG}" ]
            # ssl_access_log format
            match => [ "message", "\[%{HTTPDATE:timestamp}\] %{IPORHOST:clientip} %{WORD:ssl_proto} %{NOTSPACE:ssl_sipher} \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" (?:%{NUMBER:bytes}|-)"]
            add_tag => [ "got_apache_log", "parse_done" ]
            tag_on_failure => [ "_gpfail", "fail_ht01" ]
        }
        # if nothing above matched, we might have a corrupt or partial record.  let's try to squeak out whatever fields we can
        if !( "parse_done" in [tags]) {
            grok {
                # match first few fields from the syslog-based format
                match => [ "message", "%{SYSLOGTIMESTAMP} %{SYSLOGHOST} %{SYSLOGPROG}: %{HOSTNAME:httpd_vhost} %{IPORHOST:clientip} %{USER:ident} %{NOTSPACE:auth} \[%{HTTPDATE:timestamp}\]" ]
                # client IP address is first entry in NCSA combined/common formats
                match => [ "message", "^%{IPORHOST:clientip} %{USER:ident} %{NOTSPACE:auth} \[%{HTTPDATE:timestamp}\]" ]
                # first few fields from ssl_access_log format
                match => [ "message", "^\[%{HTTPDATE:timestamp}\] %{IPORHOST:clientIP}" ]
                # find ANY httplog-formatted date string
                match => [ "message", "\{%{HTTPDATE:timestamp}\]" ]

                add_tag => [ "got_partial_apache_log", "parse_done" ]
                tag_on_failure => [ "_gpfail", "fail_ht02" ]
            }
        }

        if "[timestamp]" {
            date {
                match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
                remove_field => [ "timestamp" ]
            }
        }

        if [bytes] {
            mutate {
                convert => [ "bytes", "integer" ]
            }
        }
        if [referrer] {
            mutate {
                gsub => [ "referrer", "\"", "" ]
            }
        }
        if [agent] {
            mutate {
                gsub => [ "agent", "\"", "" ]
            }
        }

        if [httpd_vhost] {
            mutate {
                add_tag => [ "got_vhost" ]
            }
        }
        if [program] {
            mutate {
                remove_field => [ "program" ]
            }
        }

        if [ssl_proto] {
            mutate {
                add_tag => [ "got_ssl_requestlog" ]
            }
        }

        if [clientip] {
            geoip {
                database => "/usr/local/share/GeoIP/GeoLiteCity.dat"
                source => "clientip"
                target => "client_geoip"
            }
            geoip {
                database => "/usr/local/share/GeoIP/GeoIPASNum.dat"
                source => "clientip"
                target => "client_asn"
            }
        }
    }
        if "parse_done" in [tags] {
            mutate {
                remove_field => [ "message" ]
            }
        }
    }
